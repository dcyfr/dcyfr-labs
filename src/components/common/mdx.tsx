import * as React from 'react';
import { MDXRemote, type MDXRemoteProps } from 'next-mdx-remote/rsc';
import remarkGfm from 'remark-gfm';
import remarkMath from 'remark-math';
import remarkSmartypants from 'remark-smartypants';
import rehypeSlug from 'rehype-slug';
import rehypeAutolinkHeadings from 'rehype-autolink-headings';
import rehypePrettyCode from 'rehype-pretty-code';
import rehypeKatex from 'rehype-katex';
import type { Options as RehypePrettyCodeOptions } from 'rehype-pretty-code';
import {
  CopyCodeButton,
  CodeBlockWithHeader,
  EnhancedInlineCode,
  getInlineCodeVariant,
  HorizontalRule,
  ZoomableImage,
  Alert,
  KeyTakeaway,
  ContextClue,
  Figure,
  FigureProvider,
  TableCaption,
  CodePlayground,
} from '@/components/common';
import {
  RiskAccordion,
  RiskAccordionGroup,
  ReadingProgressTracker,
  TLDRSummary,
  GlossaryTooltip,
  SectionShare,
  CollapsibleSection,
  RoleBasedCTA,
  Footnotes,
  SeriesBackgroundNote,
  RiskMatrix,
  DownloadableAsset,
  FAQSchema,
  NewsletterSignup,
  TabInterface,
  SeriesNavigation,
} from '@/components/blog';
import {
  MDXMCPArchitecture,
  MDXAuthenticationFlow,
  MDXPipelineFlow,
  MDXCVEDecisionTree,
} from '@/components/common';
import { RivetPillarCard } from '@/components/blog';
import { FAQ } from '@/components/common';
import { ProgressiveParagraph, ContrastText } from '@/components/common';
import {
  Check,
  X,
  ArrowUpLeft,
  AlertTriangle,
  Info,
  Lightbulb,
  Zap,
  Lock,
  Star,
  Rocket,
  BarChart,
  Shield,
  // RIVET blog post icons
  Compass,
  BarChart3,
  Target,
  SlidersHorizontal,
  TrendingUp,
  TrendingDown,
  CheckCircle,
  Calendar,
} from 'lucide-react';
import {
  TYPOGRAPHY,
  SPACING,
  PROGRESSIVE_TEXT,
  FONT_CONTRAST,
  ANIMATION,
} from '@/lib/design-tokens';
import { cn } from '@/lib/utils';
import {
  MDXProgressionContext,
  MDXProgressionProvider,
  MDXParagraphComponent,
} from './mdx-progression-context';

/**
 * MDX Paragraph Component with Progressive Styling
 */

/**
 * Modern table component wrapper for MDX
 * Features:
 * - Rounded corners with card-like styling
 * - Subtle depth with shadows and hover effects
 * - Responsive overflow handling
 * - Figure caption support for table descriptions
 * - Design token integration for consistent styling
 */
function TableWrapper(props: React.HTMLAttributes<HTMLTableElement>) {
  const tableId = React.useId();
  return (
    <figure className="my-8 w-full group" role="table" aria-labelledby={`${tableId}-caption`}>
      <div
        className={cn(
          'relative overflow-hidden rounded-xl border border-border bg-card shadow-sm',
          ANIMATION.transition.theme,
          'hover:shadow-md'
        )}
      >
        <div className="overflow-x-auto">
          <table {...props} className="w-full border-collapse" id={tableId} />
        </div>
      </div>
    </figure>
  );
}

/**
 * Configuration for the rehype-pretty-code plugin
 * Uses GitHub's high contrast theme for better visibility
 * - GitHub Dark High Contrast theme for dark mode
 * - GitHub Light High Contrast theme for light mode
 * - Line and character highlighting support
 * - Empty line prevention in grid layout
 * - Configurable default language (plaintext for unknown languages)
 *
 * @type {RehypePrettyCodeOptions}
 */
const rehypePrettyCodeOptions: RehypePrettyCodeOptions = {
  theme: {
    dark: 'github-dark-high-contrast',
    light: 'github-light-high-contrast',
  },
  defaultLang: 'plaintext',
  keepBackground: true,
  // Prevent lines from collapsing in `display: grid` mode
  onVisitLine(node) {
    if (node.children.length === 0) {
      node.children = [{ type: 'text', value: ' ' }];
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className = node.properties.className || [];
    node.properties.className.push('highlighted');
  },
  onVisitHighlightedChars(node) {
    node.properties.className = ['word'];
  },
};

/**
 * Custom rehype plugin to add a wrapper component marker to footnotes section
 * and remove the duplicate "Footnotes" heading that remark-gfm generates
 *
 * The Footnotes component creates its own heading, so we need to remove
 * the one generated by the markdown processor to avoid duplication.
 */
function rehypeWrapFootnotes() {
  return (tree: any) => {
    const visit = (node: any) => {
      if (
        node.type === 'element' &&
        node.tagName === 'section' &&
        node.properties?.dataFootnotes === true
      ) {
        // Mark this node as a footnotes section
        node.properties = node.properties || {};
        node.properties['data-mdx-footnotes-wrapper'] = 'true';

        // Remove the "Footnotes" heading that remark-gfm generates
        // since the Footnotes component provides its own heading
        if (node.children && Array.isArray(node.children)) {
          node.children = node.children.filter((child: any) => {
            // Remove h2 headings that contain "Footnotes" text
            if (child.type === 'element' && child.tagName === 'h2') {
              const hasFootnotesText = child.children?.some(
                (textNode: any) => textNode.type === 'text' && textNode.value === 'Footnotes'
              );
              return !hasFootnotesText;
            }
            return true;
          });
        }
      }

      // Recursively visit children
      if (node.children && Array.isArray(node.children)) {
        node.children.forEach(visit);
      }
    };

    visit(tree);
  };
}

/**
 * Custom rehype plugin to replace footnote backref emoji (↩) with an accessible element
 * This processes the HTML tree after remark-gfm adds footnotes
 */
function rehypeReplaceFootnoteEmoji() {
  return (tree: any) => {
    // Visit all nodes in the tree
    const visit = (node: any) => {
      if (node.type === 'element' && node.tagName === 'a') {
        // Look for footnote backref links (they have specific class patterns)
        if (node.properties?.href?.toString().includes('user-content-fnref')) {
          // Check if the link contains the ↩ emoji
          const hasEmoji = node.children?.some(
            (child: any) => child.type === 'text' && child.value?.includes('↩')
          );

          if (hasEmoji) {
            // Replace text children containing ↩ with a marker we can target
            node.children = node.children?.map((child: any) =>
              child.type === 'text' && child.value?.includes('↩')
                ? { type: 'text', value: 'FOOTNOTE_BACKREF' }
                : child
            );
            // Add a data attribute to mark this as a footnote backref
            node.properties = node.properties || {};
            node.properties['data-footnote-backref'] = 'true';
          }
        }
      }

      // Recursively visit children
      if (node.children && Array.isArray(node.children)) {
        node.children.forEach(visit);
      }
    };

    visit(tree);
  };
}

/**
 * Custom rehype plugin to capture code block language from rehype-pretty-code
 *
 * Problem: rehype-pretty-code v0.10+ changed behavior - it doesn't always add
 * data-language to the code element in a way React can access.
 *
 * Solution: This plugin runs after rehypePrettyCode and extracts the language
 * from the pre element's data-language attribute (if present) and ensures
 * the code child has it accessible to React components.
 */
function rehypeCaptureCodeLanguage() {
  return (tree: any) => {
    const visit = (node: any) => {
      // Look for pre elements
      if (node.type === 'element' && node.tagName === 'pre') {
        const codeChild = node.children?.find(
          (child: any) => child.type === 'element' && child.tagName === 'code'
        );

        if (codeChild && codeChild.properties) {
          // The pre element itself should have language info from rehypePrettyCode
          // Check various possible attributes where language might be stored
          let language =
            node.properties?.['data-language'] || // pre element might have it
            codeChild.properties['data-language'] || // code element might have it
            node.properties?.['data-meta']?.[0] || // meta might contain language
            undefined;

          // If we still don't have a language but the code was highlighted,
          // we can infer it was processed by rehypePrettyCode
          // Check if code child has any span children with style attributes (syntax highlighting)
          const hasHighlight =
            codeChild.children?.some(
              (child: any) =>
                child.type === 'element' && child.tagName === 'span' && child.properties?.style
            ) || codeChild.properties?.style;

          // Ensure data-language is set
          if (
            !codeChild.properties['data-language'] ||
            codeChild.properties['data-language'] === ''
          ) {
            codeChild.properties['data-language'] = language || 'plaintext';
          }

          // Also ensure the pre element has it for reference
          if (!node.properties) {
            node.properties = {};
          }
          if (!node.properties['data-language']) {
            node.properties['data-language'] = language || 'plaintext';
          }
        }
      }

      // Recursively visit children
      if (node.children && Array.isArray(node.children)) {
        node.children.forEach(visit);
      }
    };

    visit(tree);
  };
}

/**
 * Helper function to extract text content from React children recursively
 */
function extractTextFromChildren(children: React.ReactNode): string {
  if (typeof children === 'string') {
    return children;
  }
  if (Array.isArray(children)) {
    return children.map(extractTextFromChildren).join('');
  }
  if (React.isValidElement(children) && children.props) {
    const props = children.props as { children?: React.ReactNode };
    return extractTextFromChildren(props.children);
  }
  return '';
}

/**
 * Custom component mapping for MDX elements
 * Maps HTML/Markdown elements to styled React components using Tailwind CSS.
 *
 * Includes:
 * - Heading hierarchy (h1-h3) with serif fonts and proper spacing
 * - Paragraph styling with leading and margin adjustment
 * - Code blocks with theme-aware syntax highlighting
 * - Inline code with monospace font and border
 * - Lists with proper indentation
 * - Blockquotes with left border and italics
 * - Links with external link handling and underline styling
 * - Horizontal rules for content separation
 *
 * @type {NonNullable<MDXRemoteProps["components"]>}
 */
// Map a few elements to tailwind-styled components
const components: NonNullable<MDXRemoteProps['components']> = {
  h1: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h1
      {...props}
      className={`${TYPOGRAPHY.h1.mdx} mt-8 first:mt-0 scroll-mt-20 group [&_a]:no-underline`}
    />
  ),
  h2: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h2 {...props} className={`${TYPOGRAPHY.h2.mdx} mt-8 scroll-mt-20 group [&_a]:no-underline`} />
  ),
  h3: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h3 {...props} className={`${TYPOGRAPHY.h3.mdx} mt-6 scroll-mt-20 group [&_a]:no-underline`} />
  ),
  h4: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h4 {...props} className={`${TYPOGRAPHY.h4.mdx} mt-5 scroll-mt-20 group [&_a]:no-underline`} />
  ),
  h5: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h5 {...props} className={`${TYPOGRAPHY.h5.mdx} mt-4 scroll-mt-20 group [&_a]:no-underline`} />
  ),
  h6: (props: React.HTMLAttributes<HTMLHeadingElement>) => (
    <h6 {...props} className={`${TYPOGRAPHY.h6.mdx} mt-4 scroll-mt-20 group [&_a]:no-underline`} />
  ),
  p: MDXParagraphComponent,
  blockquote: (props: React.HTMLAttributes<HTMLQuoteElement>) => (
    <blockquote
      {...props}
      className="mt-6 border-l-4 border-primary/30 pl-4 italic text-muted-foreground not:first:mt-0"
    />
  ),
  table: TableWrapper,
  thead: (props: React.HTMLAttributes<HTMLTableSectionElement>) => (
    <thead {...props} className="bg-linear-to-r from-muted/80 to-muted/60 backdrop-blur-sm" />
  ),
  tbody: (props: React.HTMLAttributes<HTMLTableSectionElement>) => <tbody {...props} />,
  tr: (props: React.HTMLAttributes<HTMLTableRowElement>) => (
    <tr
      {...props}
      className="border-b border-border/50 transition-colors hover:bg-muted/30 last:border-b-0"
    />
  ),
  th: (props: React.HTMLAttributes<HTMLTableCellElement>) => (
    <th
      {...props}
      className={cn(
        'px-4 py-4 text-left font-semibold',
        TYPOGRAPHY.label.small,
        'text-foreground/90 tracking-wide'
      )}
    />
  ),
  td: (props: React.HTMLAttributes<HTMLTableCellElement>) => (
    <td {...props} className="px-4 py-4 text-sm leading-relaxed text-foreground/90" />
  ),
  strong: (props: React.HTMLAttributes<HTMLElement>) => (
    <ContrastText.Bold as="strong" {...props} />
  ),
  em: (props: React.HTMLAttributes<HTMLElement>) => <ContrastText.Emphasis as="em" {...props} />,
  ul: (props: React.HTMLAttributes<HTMLUListElement>) => {
    // Check if this is a task list (contains checkboxes)
    const children = React.Children.toArray(props.children);
    const hasCheckboxes = children.some((child) => {
      if (React.isValidElement(child) && child.type === 'li') {
        const liChildren = React.Children.toArray(child.props.children);
        return liChildren.some(
          (liChild) =>
            React.isValidElement(liChild) &&
            liChild.type === 'input' &&
            (liChild.props as any)?.type === 'checkbox'
        );
      }
      return false;
    });

    return (
      <ul
        {...props}
        className={cn(hasCheckboxes ? 'list-none pl-6' : 'list-disc pl-6', SPACING.list)}
      />
    );
  },
  ol: (props: React.HTMLAttributes<HTMLOListElement>) => (
    <ol {...props} className={cn('list-decimal pl-6', SPACING.list)} />
  ),
  // Note: SPACING.list = space-y-0.5 is used for list items spacing
  code: (props: React.HTMLAttributes<HTMLElement>) => {
    // Inline code (no data-language attribute)
    const isInline = !props['data-language' as keyof typeof props];
    if (isInline) {
      // Extract text content to determine variant
      const textContent = React.Children.toArray(props.children)
        .map((child) => (typeof child === 'string' ? child : ''))
        .join('');

      const variant = getInlineCodeVariant(textContent);

      return (
        <EnhancedInlineCode {...props} variant={variant}>
          {props.children}
        </EnhancedInlineCode>
      );
    }
    // Code blocks handled by pre > code (rehype-pretty-code)
    return <code {...props} />;
  },
  pre: (props: React.HTMLAttributes<HTMLPreElement>) => {
    // Extract language from the code child element's data-language attribute
    // or from the pre element itself (fallback)
    const codeChild = React.Children.toArray(props.children).find(
      (child): child is React.ReactElement => React.isValidElement(child) && child.type === 'code'
    );

    let language = codeChild?.props
      ? ((codeChild.props as any)['data-language'] as string | undefined)
      : undefined;

    // Fallback: check if language is on the pre element itself
    if (!language && props['data-language' as keyof typeof props]) {
      language = props['data-language' as keyof typeof props] as string;
    }

    return <CodeBlockWithHeader language={language}>{props.children}</CodeBlockWithHeader>;
  },
  kbd: (props: React.HTMLAttributes<HTMLElement>) => (
    <kbd
      {...props}
      className={cn(
        'inline-flex items-center',
        'px-2 py-0.5',
        'text-[0.75em] font-mono font-semibold',
        'rounded border',
        'bg-muted/50 text-muted-foreground border-border',
        'shadow-sm',
        'hover:bg-muted/70 hover:border-border-hover',
        ANIMATION.transition.theme,
        props.className
      )}
    />
  ),
  hr: () => <HorizontalRule />,
  a: (props: React.AnchorHTMLAttributes<HTMLAnchorElement>) => {
    const isHeaderAnchor = props.className?.includes('no-underline');
    const href = props.href || '';
    const isExternal = href.startsWith('http://') || href.startsWith('https://');
    const isFootnoteBackref = href.includes('user-content-fnref');

    // Handle footnote backref links - replace emoji with icon
    if (isFootnoteBackref) {
      return (
        <a
          {...props}
          href={href}
          className="no-underline inline-flex items-center pl-2 text-muted-foreground hover:text-foreground transition-colors"
          title="Back to note reference"
        >
          <ArrowUpLeft className="inline-block w-3 h-3" aria-label="Back to note" />
        </a>
      );
    }

    // Convert relative docs links to proper /dev/docs/ paths
    let adjustedHref = href;
    if (href.startsWith('./')) {
      adjustedHref = `/dev/docs/${href.slice(2)}`;
    }

    return (
      <a
        {...props}
        href={adjustedHref}
        className={
          isHeaderAnchor
            ? 'hover:text-primary no-underline'
            : 'inline-flex items-center gap-1 hover:text-primary'
        }
        {...(isExternal && {
          target: '_blank',
          rel: 'noopener noreferrer',
        })}
      >
        {props.children}
        {isExternal && !isHeaderAnchor && (
          <svg
            className="h-4 w-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
            aria-hidden="true"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
            />
          </svg>
        )}
      </a>
    );
  },
  img: (props: React.ImgHTMLAttributes<HTMLImageElement>) => (
    <ZoomableImage {...props} className={`${SPACING.image} rounded-lg max-w-full h-auto`} />
  ),
  // Icon components for consistent styling across the site
  // Note: Icon colors converted to monochrome (text-muted-foreground)

  CheckIcon: () => (
    <Check className="inline-block w-5 h-5 align-text-bottom text-success" aria-label="Check" />
  ),
  XIcon: () => (
    <X className="inline-block w-5 h-5 align-text-bottom text-error" aria-label="Cross" />
  ),
  ReturnIcon: () => (
    <ArrowUpLeft
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Return"
    />
  ),
  WarningIcon: () => (
    <AlertTriangle
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Warning"
    />
  ),
  InfoIcon: () => (
    <Info className="inline-block w-5 h-5 align-text-bottom text-info" aria-label="Information" />
  ),
  IdeaIcon: () => (
    <Lightbulb
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Idea"
    />
  ),
  ZapIcon: () => (
    <Zap
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Lightning"
    />
  ),
  LockIcon: () => (
    <Lock
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Lock"
    />
  ),
  StarIcon: () => (
    <Star
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Star"
    />
  ),
  RocketIcon: () => (
    <Rocket
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Rocket"
    />
  ),
  BarChart: () => (
    <BarChart
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Bar Chart"
    />
  ),
  BarChartIcon: () => (
    <BarChart
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Bar Chart"
    />
  ),
  Shield: () => (
    <Shield
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Shield"
    />
  ),
  ShieldIcon: () => (
    <Shield
      className="inline-block w-5 h-5 align-text-bottom text-muted-foreground"
      aria-label="Shield"
    />
  ),
  // RIVET blog post icons - direct lucide component mappings
  Compass,
  BarChart3,
  Target,
  SlidersHorizontal,
  TrendingUp,
  TrendingDown,
  CheckCircle,
  Calendar,
  Check,
  X,
  // RIVET pillar card component
  RivetPillarCard,

  // Diagram presets (using ReactFlow) - imported from client-side wrapper
  // These use "use client" to prevent SSR bailout errors
  MCPArchitecture: MDXMCPArchitecture as any,
  AuthenticationFlow: MDXAuthenticationFlow as any,
  PipelineFlow: MDXPipelineFlow as any,
  CVEDecisionTree: MDXCVEDecisionTree as any,
  // FAQ component
  FAQ,
  // Alert component for banners
  Alert,
  // Key Takeaway component for insights
  KeyTakeaway,
  // TLDR Summary component for executive summaries
  TLDRSummary,
  // Glossary Tooltip component for technical terms
  GlossaryTooltip,
  // Section Share component for per-section social sharing
  SectionShare,
  // Collapsible Section component for expandable content
  CollapsibleSection,
  // Role-based CTA component for audience segmentation
  RoleBasedCTA,
  // Series Background Note component for series context with previous post links
  SeriesBackgroundNote,
  // P2 Advanced Features
  // Risk Matrix component for visual risk assessment
  RiskMatrix,
  // Downloadable Asset component for lead capture with file delivery
  DownloadableAsset,
  // FAQ Schema component for SEO-optimized FAQ sections
  FAQSchema,
  // Newsletter Signup component for email capture
  NewsletterSignup,
  // Tab Interface component for interactive tabbed content
  TabInterface,
  // Series Navigation component for multi-part series navigation
  SeriesNavigation,
  // Context Clue component for background information
  ContextClue,
  // Figure caption component for automatic figure numbering
  Figure,
  // Table caption component for table descriptions
  TableCaption,
  // Code Playground component for interactive examples
  CodePlayground,
  // Risk Accordion components for interactive risk sections
  RiskAccordion,
  RiskAccordionGroup,
  // Reading Progress Tracker for engagement tracking
  ReadingProgressTracker,
  // CVE/Security components temporarily disabled - see blog post updates
  // SeverityLabel,
  // CVELink,
  // CVETracker,
  // CVEFootnote,
  // Footnote superscripts with icon
  sup: (props: React.HTMLAttributes<HTMLElement>) => {
    // Check if this contains a link (footnote reference) or has footnote-related attributes
    const children = React.Children.toArray(props.children);
    const hasLink = children.some((child) => React.isValidElement(child) && child?.type === 'a');

    if (hasLink) {
      // This is a footnote reference - replace the content with our icon
      // Get the href from the link to preserve navigation
      const linkChild = children.find(
        (child) => React.isValidElement(child) && child?.type === 'a'
      ) as React.ReactElement | undefined;

      const href = (linkChild?.props as { href?: string })?.href;

      return (
        <sup {...props} className="ml-0.5 inline-flex items-center">
          <a href={href} className="no-underline hover:opacity-70 transition-opacity">
            <ArrowUpLeft
              className="inline-block w-3 h-3 text-primary"
              aria-label="Footnote reference"
            />
          </a>
        </sup>
      );
    }

    // Default superscript for non-footnote uses
    return <sup {...props} />;
  },
  // Footnotes section handler - wrap footnotes in collapsible component
  section: (props: React.HTMLAttributes<HTMLElement>) => {
    const hasDataFootnotes =
      (props as any)['data-footnotes'] === true ||
      (props as any)['data-mdx-footnotes-wrapper'] === 'true';

    if (hasDataFootnotes) {
      return (
        <Footnotes>
          <section {...props} data-footnotes={undefined} />
        </Footnotes>
      );
    }

    // Default section for non-footnote uses
    return <section {...props} />;
  },
};

/**
 * MDX Component
 *
 * Renders MDX (Markdown + JSX) content with rich formatting, syntax highlighting,
 * and automatic table of contents generation.
 *
 * Processing Pipeline:
 * 1. **Remark plugins**:
 *    - remark-gfm: GitHub-flavored markdown (tables, strikethrough, task lists)
 *
 * 2. **Rehype plugins** (in order):
 *    - rehype-slug: Generates IDs for headings (used by TOC and anchor links)
 *    - rehype-pretty-code: Syntax highlighting with Shiki (dual-theme support)
 *    - rehype-autolink-headings: Wraps headings with self-referential links
 *
 * 3. **Component mapping**:
 *    - Custom Tailwind-styled components for HTML elements
 *    - Consistent typography and spacing via utility classes
 *    - Theme-aware styling (light/dark mode)
 *
 * @component
 * @param {Object} props - Component props
 * @param {string} props.source - Raw MDX source code to render
 *
 * @returns {React.ReactElement} Rendered MDX content with styled elements
 *
 * @example
 * // Render blog post content
 * const mdxSource = "# Hello World\n\nThis is **bold** text.";
 * <MDX source={mdxSource} />
 *
 * @features
 * - **Syntax Highlighting**: Code blocks use Shiki with github-light/github-dark-dimmed themes
 * - **Auto-generated Headings IDs**: Headings get slugified IDs for linking
 * - **Header Links**: Heading anchors for direct navigation
 * - **GitHub Tables**: Support for markdown tables
 * - **Task Lists**: Checkbox lists in markdown
 * - **External Links**: Automatic target="_blank" and rel="noopener noreferrer"
 * - **Theme Aware**: All components respect light/dark mode preferences
 *
 * @performance
 * - Server-side rendering: MDX processing happens at build time via next-mdx-remote/rsc
 * - No client-side JavaScript overhead for rendering
 * - Syntax highlighting pre-computed during build
 *
 * @accessibility
 * - Semantic HTML structure with proper heading hierarchy
 * - Links are keyboard accessible and screen reader friendly
 * - Code blocks have proper language hints for assistive technology
 * - Heading anchors wrap the entire heading for better click targets
 *
 * @see /docs/components/mdx.md for detailed documentation
 */
export function MDX({
  source,
  useFontContrast = false,
}: {
  source: string;
  useFontContrast?: boolean;
}) {
  return (
    <MDXProgressionProvider useFontContrast={useFontContrast}>
      <MDXRemote
        source={source}
        options={{
          mdxOptions: {
            remarkPlugins: [
              remarkGfm,
              remarkMath, // Parse math notation
              remarkSmartypants, // Convert --- to em-dashes, quotes to smart quotes
            ],
            rehypePlugins: [
              rehypeSlug,
              [rehypePrettyCode, rehypePrettyCodeOptions],
              rehypeCaptureCodeLanguage, // Capture language from rehypePrettyCode output
              rehypeKatex, // Render math with KaTeX
              rehypeWrapFootnotes, // Mark footnotes sections for collapsible wrapping
              rehypeReplaceFootnoteEmoji, // Replace footnote emoji with icon
              [
                rehypeAutolinkHeadings,
                {
                  behavior: 'wrap',
                  properties: {
                    className: 'no-underline hover:text-primary transition-colors',
                  },
                },
              ],
            ],
          },
        }}
        components={components}
      />
    </MDXProgressionProvider>
  );
}
