---
title: "Getting Started with React Hooks"
description: "Learn React Hooks with interactive examples you can edit and run. Covers useState, custom hooks, and TypeScript patterns."
summary: "A comprehensive guide to React Hooks with interactive, editable code examples. Learn useState, custom hooks, and TypeScript patterns with live demonstrations of counter, todo, and localStorage implementations."
publishedAt: "2025-12-26T00:00:00Z"
updatedAt: "2025-12-26T00:00:00Z"
author: "Drew"
tags: ["React", "Hooks", "JavaScript", "TypeScript"]
featured: false
archived: false
---

# Getting Started with React Hooks

Learn how to use React Hooks to manage state and side effects in functional components. This guide includes interactive examples you can edit and run right in your browser.

## What Are React Hooks?

React Hooks are functions that let you "hook into" React features. They were introduced in React 16.8 as a way to write stateful logic in functional components, eliminating the need for class components.

<ContextClue>
Hooks solve the problem of code reuse in React. Before hooks, sharing stateful logic between components was difficult and often required higher-order components or render props.
</ContextClue>

## The useState Hook

The most basic and commonly used hook is `useState`. It lets you add state to your functional components.

### Try It: Interactive Counter

Edit the code below to explore how `useState` works. Try changing the increment value or adding a reset button!

<CodePlayground template="react-counter" />

**What's happening:**
1. `useState(0)` creates a state variable `count` and `setCount` function
2. The initial value is `0`
3. When you click "Increment", `setCount` updates the state
4. React re-renders the component with the new value

## Building a Custom Hook

One of the most powerful features of hooks is the ability to build your own. Here's a practical example:

<CodePlayground template="react-hook-localstorage" height="600px" />

**This custom hook:**
- Syncs state with localStorage automatically
- Persists data across browser refreshes
- Returns the same API as useState
- Can be reused across multiple components

<KeyTakeaway>
Custom hooks are just JavaScript functions that use other hooks. They let you extract component logic into reusable functions that work across your entire app.
</KeyTakeaway>

## TypeScript + Hooks

If you're using TypeScript, here's how to build a type-safe todo app with hooks:

<CodePlayground template="typescript-todo" />

**Benefits of this approach:**
- âœ… Full type safety with TypeScript
- âœ… IntelliSense in your editor
- âœ… Catch errors at development time
- âœ… Self-documenting code

## Best Practices

### 1. Always Call Hooks at the Top Level
```javascript
// âŒ WRONG - Conditional hook call
if (user) {
  const [name, setName] = useState("");
}

// âœ… CORRECT - Hook always called
const [name, setName] = useState(user?.name || "");
```

### 2. Use useEffect for Side Effects
```javascript
// Load data when component mounts
useEffect(() => {
  fetchUserData(userId);
}, [userId]);  // Re-run if userId changes
```

### 3. Extract Logic into Custom Hooks
Instead of repeating hook logic, create custom hooks to share it:
```javascript
// Before: Logic repeated in multiple components
const [count, setCount] = useState(0);

// After: Reusable custom hook
const [count, setCount] = useCounter(0);
```

## Common Hooks Cheat Sheet

| Hook | Purpose | Example |
|------|---------|---------|
| `useState` | Manage state | `const [count, setCount] = useState(0)` |
| `useEffect` | Handle side effects | `useEffect(() => {}, [])` |
| `useContext` | Use context values | `const value = useContext(MyContext)` |
| `useReducer` | Complex state logic | `const [state, dispatch] = useReducer(reducer, init)` |
| `useCallback` | Memoize functions | `const memoized = useCallback(() => {}, [])` |
| `useMemo` | Memoize values | `const memoized = useMemo(() => value, [])` |
| `useRef` | Access DOM directly | `const inputRef = useRef(null)` |

## Conclusion

React Hooks revolutionized how we write components. They make code more reusable, testable, and easier to understand. The three examples above show:

1. **useState** - The foundation of stateful functional components
2. **Custom Hooks** - How to extract and share logic
3. **TypeScript** - Type safety and better development experience

Now go build something amazing! ðŸš€

---

**Resources:**
- [React Hooks Official Docs](https://react.dev/reference/react/hooks)
- [Rules of Hooks](https://react.dev/warnings/invalid-hook-call-warning)
- [Custom Hooks Guide](https://react.dev/learn/reusing-logic-with-custom-hooks)
