# Security Vulnerability Troubleshooting Guide

**Version:** 1.0  
**Created:** December 23, 2025  
**Purpose:** Workflow for analyzing, fixing, and preventing security vulnerabilities found by CodeQL and other scanners

---

## üîç Quick Workflow: Analyzing Code Scanning Alerts

### Step 1: Access the Alert

```bash
# Via GitHub CLI
gh api repos/dcyfr/dcyfr-labs/code-scanning/alerts --jq '.[] | select(.number == ALERT_ID)'

# Via Web Interface
https://github.com/dcyfr/dcyfr-labs/security/code-scanning/ALERT_ID
```

### Step 2: Extract Key Information

Required details:
- **Alert Number** - Unique identifier
- **Severity** - `error` (critical), `warning` (high/medium), `note` (low)
- **Rule ID** - CWE identifier (e.g., `js/request-forgery`)
- **File Path** - Affected source file
- **Line Numbers** - Exact location in code
- **Message** - Description of the issue

### Step 3: Root Cause Analysis

```typescript
// Example: SSRF vulnerability
const url = `https://api.example.com/${userInput}`; // ‚ùå Problem
// Root Cause: User input directly in URL without validation
```

**Common root causes:**
- Direct string interpolation into sensitive constructs (URLs, commands, paths)
- Missing input validation or sanitization
- Insufficient URL/command parsing
- Trusting untrusted data sources

### Step 4: Determine Risk Level

| Factor | Assessment |
|--------|-----------|
| User Control | Is input directly from user? (High risk) |
| Scope | What can attacker do? (Severity) |
| Context | Is this in API, form handler, file ops? |
| Default | Are security defaults enabled? |

### Step 5: Implement Targeted Fix

See vulnerability-specific guides below.

### Step 6: Add Comprehensive Tests

```typescript
describe("Security Tests - CWE-XXX", () => {
  it("should reject malicious input: XYZ attack", () => {
    // Test the specific attack vector
  });
  
  it("should accept valid input", () => {
    // Test legitimate use cases
  });
  
  it("should construct safe output", () => {
    // Verify secure construction
  });
});
```

### Step 7: Validate Fully

```bash
npm run test          # Security tests pass
npm run lint          # ESLint 0 errors
npm run typecheck     # TypeScript strict mode
npm run check         # All validation gates
```

---

## üîê Vulnerability-Specific Guides

### SSRF (CWE-918): Server-Side Request Forgery

**Pattern:** User input in outgoing HTTP request URL

#### Detection
```typescript
// ‚ùå BAD: User input in URL
const userProvidedUrl = req.query.url;
fetch(`https://api.example.com?redirect=${userProvidedUrl}`);

// ‚ùå BAD: User input in hostname
const hostname = req.body.host;
fetch(`https://${hostname}/api/data`);
```

#### Prevention Strategy (3 Layers)

**Layer 1: Input Validation (Whitelist)**
```typescript
// Only allow safe characters
if (!/^[a-zA-Z0-9._-]+$/.test(input)) {
  throw new Error("Invalid format");
}

// Length limits prevent DoS
if (input.length > 255) {
  throw new Error("Too long");
}
```

**Layer 2: URL Constructor (Structural)**
```typescript
// Use URL constructor, not string interpolation
const url = new URL("https://api.example.com");
url.pathname = `/users/${encodeURIComponent(username)}/data`;
url.searchParams.set("key", value); // Auto-encoded

// ‚úÖ Guarantees:
// - Hostname always api.example.com
// - Protocol always https
// - No injection possible in pathname
```

**Layer 3: URL Encoding (Defense-in-Depth)**
```typescript
// Additional encoding for parameters
encodeURIComponent(userInput)  // Encodes special chars
```

#### Common SSRF Attacks
| Attack | Example | Prevention |
|--------|---------|-----------|
| Fragment injection | `user#evil.com` | Regex: reject `#` |
| Query injection | `user?admin=true` | Regex: reject `?` |
| Path traversal | `../admin` | Regex: reject `/`, `\`, `..` |
| Protocol injection | `http://evil.com` | Regex: reject `:`, `//` |
| Email format | `attacker@evil.com` | Regex: reject `@` |
| Metadata endpoints | `169.254.169.254` | Validate against whitelist |

#### Testing Approach
```typescript
describe("SSRF Prevention - CWE-918", () => {
  // Attack vectors
  it("should reject URL fragments", () => {
    expect(() => process(input: "user#evil")).toThrow();
  });
  
  // Valid patterns
  it("should accept alphanumeric", () => {
    expect(process(input: "john-doe")).toSucceed();
  });
  
  // URL structure
  it("should always use HTTPS", () => {
    const url = constructUrl("user");
    expect(new URL(url).protocol).toBe("https:");
  });
});
```

#### Example Implementation
See: [src/app/api/credly/badges/route.ts](src/app/api/credly/badges/route.ts) (Fixed in commit 75d0b0d)

---

### Log Injection (CWE-117): Log Entry Forgery

**Pattern:** User input directly in log statements

#### Detection
```typescript
// ‚ùå BAD: User input in log
console.log(`User logged in: ${req.body.username}`);
// Attacker: username = "admin\n[INFO] User: root logged in"

// ‚ùå BAD: Query parameters in logs
console.error(`Error: ${req.query.error}`);
```

#### Prevention
```typescript
// ‚úÖ GOOD: Sanitize before logging
function sanitizeForLog(input: string): string {
  return input
    .replace(/[\n\r]/g, " ")           // Remove line breaks
    .replace(/[\x00-\x1F]/g, "")       // Remove control chars
    .replace(/\x1B\[\d+m/g, "");       // Remove ANSI codes
}

console.log(`User logged in: ${sanitizeForLog(username)}`);
```

#### Testing
```typescript
it("should remove newlines from input", () => {
  const malicious = "admin\n[INFO] root logged in";
  expect(sanitizeForLog(malicious)).not.toContain("\n");
});
```

---

### Incomplete URL Sanitization (CWE-20)

**Pattern:** Substring checking instead of URL parsing

#### Detection
```typescript
// ‚ùå BAD: Substring check
if (url.includes("trusted.com")) {
  redirect(url);  // Bypass: "http://evil-trusted.com"
}

// ‚ùå BAD: Includes without hostname extraction
if (url.includes("localhost")) {
  // Bypass: "http://localhost.evil.com" or "//localhost@evil.com"
}
```

#### Prevention
```typescript
// ‚úÖ GOOD: Parse URL first
const parsed = new URL(url);
const ALLOWED_HOSTS = ["trusted.com", "api.trusted.com"];

if (ALLOWED_HOSTS.includes(parsed.hostname)) {
  redirect(url);  // Safe: hostname enforced by parser
}

// ‚úÖ GOOD: Use .endsWith() for domain matching
function isAllowedHost(hostname: string): boolean {
  return hostname === "trusted.com" || 
         hostname.endsWith(".trusted.com");
}
```

---

### File System Race Conditions (CWE-367)

**Pattern:** Check then use (TOCTOU - Time-of-Check Time-of-Use)

#### Detection
```typescript
// ‚ùå BAD: Check then operate
if (fs.existsSync(filepath)) {
  fs.writeFileSync(filepath, data);  // File might be changed between!
}
```

#### Prevention
```typescript
// ‚úÖ GOOD: Use atomic operations with flags
try {
  const fd = fs.openSync(
    filepath,
    fs.constants.O_CREAT |  // Create
    fs.constants.O_EXCL |   // Fail if exists (atomic)
    fs.constants.O_WRONLY,  // Write only
    0o600                   // Restricted permissions
  );
  fs.writeFileSync(fd, data);
  fs.closeSync(fd);
} catch (err) {
  if (err.code === "EEXIST") {
    // File was created by another process
  }
}
```

---

## üìã Security Testing Checklist

Before marking any work complete:

- [ ] **CodeQL Passing**
  - [ ] Run GitHub CLI: `gh api repos/dcyfr/dcyfr-labs/code-scanning/alerts`
  - [ ] Verify no NEW high/critical findings
  - [ ] Document any false positives with reasoning

- [ ] **Input Validation**
  - [ ] Whitelist approach (allow known good)
  - [ ] Length limits enforced
  - [ ] Special characters blocked
  - [ ] Type validation (string, number, etc.)

- [ ] **Output Encoding**
  - [ ] URL: `encodeURIComponent()` or URL constructor
  - [ ] HTML: HTML entities or templating
  - [ ] SQL: Parameterized queries
  - [ ] Shell: Avoid shell, use `execFile()`

- [ ] **Security Tests Added**
  - [ ] Attack vectors covered
  - [ ] Valid patterns tested
  - [ ] Boundary conditions tested
  - [ ] 100% pass rate

- [ ] **Documentation**
  - [ ] Comments explain "why" not just "what"
  - [ ] Security decisions documented
  - [ ] Link to CWE/OWASP
  - [ ] False positives explained

---

## üéì Lessons Learned: SSRF Prevention

**Key insight from CWE-918 fix:**

### ‚ùå What NOT to Do

```typescript
// Level 1: Raw string interpolation (VULNERABLE)
const url = `https://api.com/users/${username}/data`;

// Level 2: Basic validation then string interpolation (STILL VULNERABLE)
if (!/^[a-z]+$/.test(username)) {
  const url = `https://api.com/users/${username}/data`;
}

// Level 3: Regex validation but URL construction (VULNERABLE)
if (!/^[a-zA-Z0-9._-]+$/.test(username)) {
  const url = `https://api.com/users/${username}/data`;
}
```

### ‚úÖ What TO Do: Defense in Depth

```typescript
// Layer 1: Strict input validation (whitelist)
if (!/^[a-zA-Z0-9._-]+$/.test(username)) {
  throw new Error("Invalid username");
}
if (username.length > 255) {
  throw new Error("Username too long");
}

// Layer 2: Secure URL construction (structural guarantee)
const url = new URL("https://www.credly.com");
url.pathname = `/users/${encodeURIComponent(username)}/badges.json`;

// Layer 3: Verify safe construction (defensive coding)
if (url.hostname !== "www.credly.com") {
  throw new Error("Hostname mismatch");
}
if (url.protocol !== "https:") {
  throw new Error("Protocol mismatch");
}

// Layer 4: Comprehensive testing
// (See: SSRF Testing section above)
```

### üîë Key Principles

| Principle | Why It Matters |
|-----------|---|
| **Whitelist, Not Blacklist** | Can't block all bad chars; easier to allow known good |
| **Structural Guarantees** | URL constructor prevents breaking out of path segment |
| **Defense in Depth** | If one layer fails, others catch it |
| **Test Attack Vectors** | Test what attacker would try, not just valid input |
| **Encode Always** | Even with validation, encode for the output context |

---

## üõ†Ô∏è Tools & Commands Reference

### Analyze Alerts
```bash
# List all open alerts
gh api repos/dcyfr/dcyfr-labs/code-scanning/alerts --jq '.[] | select(.state == "open")'

# Get specific alert details
gh api repos/dcyfr/dcyfr-labs/code-scanning/alerts --jq '.[] | select(.number == 81)'

# Filter by rule (e.g., SSRF)
gh api repos/dcyfr/dcyfr-labs/code-scanning/alerts --jq '.[] | select(.rule.id == "js/request-forgery")'
```

### Validate Fix
```bash
# Run security tests
npm run test -- --grep "Security\|SSRF\|Injection"

# Full validation pipeline
npm run check

# TypeScript strict mode
npm run typecheck

# ESLint security rules
npm run lint -- --rule "@typescript-eslint/no-unsafe-*"
```

### Document Fix
```bash
# Create security documentation
# See: docs/private/SECURITY_FIX_CWE918_SSRF.md template
```

---

## üìö External References

- **OWASP:** [SSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html)
- **CWE-918:** [Server-Side Request Forgery](https://cwe.mitre.org/data/definitions/918.html)
- **CWE-20:** [Improper Input Validation](https://cwe.mitre.org/data/definitions/20.html)
- **CWE-117:** [Log Injection](https://cwe.mitre.org/data/definitions/117.html)
- **CWE-367:** [Time-of-check Time-of-use](https://cwe.mitre.org/data/definitions/367.html)
- **CodeQL:** [JavaScript/TypeScript Security Queries](https://codeql.github.com/codeql-queries/javascript/)
- **MDN:** [URL Constructor](https://developer.mozilla.org/en-US/docs/Web/API/URL)

---

## üìã Quick Decision Matrix

| Scenario | Prevention Strategy |
|----------|---|
| User provides URL to fetch | Whitelist domains, use URL constructor, validate each part |
| User provides username/ID | Regex whitelist, length limit, encodeURIComponent() |
| User provides search query | Parameterized queries (SQL), HTML escape (display), use Set for arrays |
| User provides filename | Restrict to allowed directory, no path traversal, use atomic operations |
| User provides command args | Never use `exec()`, use `execFile()` with array args |
| User in log messages | Sanitize newlines and control characters before logging |

---

**Last Updated:** December 23, 2025  
**Related Files:** 
- [docs/private/SECURITY_FIX_CWE918_SSRF.md](docs/private/SECURITY_FIX_CWE918_SSRF.md)
- [src/app/api/credly/badges/route.ts](src/app/api/credly/badges/route.ts)
- [src/app/api/credly/badges/__tests__/route.test.ts](src/app/api/credly/badges/__tests__/route.test.ts)
