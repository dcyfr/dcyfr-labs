#!/usr/bin/env node
/**
 * Execute Upstash Cleanup
 *
 * Deletes malformed and hanging reference keys identified by the analysis.
 * Uses the .upstash-cleanup-plan.json file generated by analyze-upstash-data.mjs
 */

// Load environment variables
import { config } from 'dotenv';
import { resolve } from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { readFile } from 'fs/promises';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
config({ path: resolve(__dirname, '../.env.local') });

import { redis } from '../src/mcp/shared/redis-client.ts';

async function main() {
  console.log('üßπ Upstash Cleanup Execution\n');

  // Load cleanup plan
  console.log('üìã Loading cleanup plan...');
  const cleanupPath = resolve(__dirname, '../.upstash-cleanup-plan.json');
  let cleanupPlan;

  try {
    const data = await readFile(cleanupPath, 'utf-8');
    cleanupPlan = JSON.parse(data);
  } catch (error) {
    console.error('‚ùå Could not load cleanup plan:', error.message);
    console.error('   Run: npm run redis:analyze first\n');
    process.exit(1);
  }

  const { malformed, hanging, stale } = cleanupPlan;

  // SAFETY CHECK: Never delete likes or bookmarks keys
  const protectedPrefixes = ['likes:', 'bookmarks:'];
  const safetyFilter = (key) => {
    const isProtected = protectedPrefixes.some((prefix) => key.startsWith(prefix));
    if (isProtected) {
      console.warn(`‚ö†Ô∏è  SAFETY: Skipping protected key: ${key}`);
      return false;
    }
    return true;
  };

  const safeMalformed = malformed.filter(safetyFilter);
  const safeHanging = hanging.filter(safetyFilter);
  const safeStale = stale.filter(safetyFilter);

  const skippedCount =
    malformed.length -
    safeMalformed.length +
    (hanging.length - safeHanging.length) +
    (stale.length - safeStale.length);

  const immediateCleanup = [...safeMalformed, ...safeHanging];

  console.log(`  ‚úì Malformed keys: ${safeMalformed.length}`);
  console.log(`  ‚úì Hanging references: ${safeHanging.length}`);
  console.log(`  ‚úì Stale keys: ${safeStale.length}`);
  if (skippedCount > 0) {
    console.log(`  üõ°Ô∏è  Protected keys skipped: ${skippedCount} (likes/bookmarks)`);
  }
  console.log('');

  if (immediateCleanup.length === 0) {
    console.log('‚ú® No keys to cleanup - your database is clean!\n');
    return;
  }

  console.log('üìù CLEANUP SUMMARY');
  console.log('-'.repeat(80));
  console.log(`Will DELETE ${immediateCleanup.length} keys:`);
  console.log(`  - ${malformed.length} malformed keys (undefined/null/empty)`);
  console.log(`  - ${hanging.length} hanging references (posts that don't exist)\n`);

  console.log('‚ö†Ô∏è  STALE KEYS NOT INCLUDED:');
  console.log(`  - ${stale.length} stale keys (>90 days) will NOT be deleted`);
  console.log(`  - Use --include-stale flag to also delete stale keys\n`);

  // Show sample keys
  console.log('üîç SAMPLE KEYS TO BE DELETED:');
  console.log('-'.repeat(80));

  if (malformed.length > 0) {
    console.log('Malformed:');
    for (const key of malformed.slice(0, 5)) {
      console.log(`  ‚ùå ${key}`);
    }
    if (malformed.length > 5) console.log(`  ... and ${malformed.length - 5} more`);
    console.log('');
  }

  if (hanging.length > 0) {
    console.log('Hanging references:');
    for (const key of hanging.slice(0, 5)) {
      console.log(`  ‚ùå ${key}`);
    }
    if (hanging.length > 5) console.log(`  ... and ${hanging.length - 5} more`);
    console.log('');
  }

  // Confirmation
  const includeStale = process.argv.includes('--include-stale');
  const keysToDelete = includeStale ? [...immediateCleanup, ...safeStale] : immediateCleanup;

  // FINAL SAFETY CHECK: Double-check no protected keys made it through
  const finalProtectedCheck = keysToDelete.filter(
    (key) => key.startsWith('likes:') || key.startsWith('bookmarks:')
  );

  if (finalProtectedCheck.length > 0) {
    console.error('‚ùå SAFETY ERROR: Protected keys detected in deletion list!');
    console.error('   Keys:', finalProtectedCheck);
    console.error('   ABORTING cleanup to prevent data loss.\n');
    process.exit(1);
  }

  if (includeStale) {
    console.log('‚ö†Ô∏è  INCLUDING STALE KEYS in cleanup (--include-stale flag detected)');
    console.log(`   Total keys to delete: ${keysToDelete.length}\n`);
  }

  console.log('‚è≥ Starting cleanup in 5 seconds...');
  console.log('   Press Ctrl+C to cancel\n');

  // Pre-cleanup verification: Count current likes and bookmarks
  console.log('üîç Pre-cleanup verification...');
  const likesCount = await redis.scan('0', { match: 'likes:*', count: 200 });
  const bookmarksCount = await redis.scan('0', { match: 'bookmarks:*', count: 200 });
  const currentLikes = likesCount[1].length;
  const currentBookmarks = bookmarksCount[1].length;

  console.log(`  Current likes keys: ${currentLikes}`);
  console.log(`  Current bookmarks keys: ${currentBookmarks}`);
  console.log(`  ‚úÖ These counts will NOT change after cleanup\n`);

  await new Promise((resolve) => setTimeout(resolve, 5000));

  // Execute deletion
  console.log('üóëÔ∏è  Deleting keys...\n');

  let deleted = 0;
  let failed = 0;
  const errors = [];

  for (let i = 0; i < keysToDelete.length; i++) {
    const key = keysToDelete[i];

    try {
      await redis.del(key);
      deleted++;

      if ((i + 1) % 10 === 0) {
        console.log(`  Progress: ${i + 1}/${keysToDelete.length} keys processed...`);
      }
    } catch (error) {
      failed++;
      errors.push({ key, error: error.message });
      console.error(`  ‚ùå Failed to delete: ${key}`);
    }
  }

  // Summary
  console.log('\n' + '='.repeat(80));
  console.log('üìä CLEANUP COMPLETE');
  console.log('='.repeat(80) + '\n');

  console.log(`‚úÖ Successfully deleted: ${deleted} keys`);
  console.log(`‚ùå Failed: ${failed} keys\n`);

  if (errors.length > 0) {
    console.log('‚ùå ERRORS:');
    for (const { key, error } of errors) {
      console.log(`  ${key}: ${error}`);
    }
    console.log('');
  }

  // Verify
  console.log('üîç Verifying cleanup...');
  const scanResult = await redis.scan('0', { count: 10 });
  const remainingKeys = parseInt(scanResult[0]) === 0 ? scanResult[1].length : '~350+';
  console.log(`  Remaining keys in database: ${remainingKeys}`);

  // Post-cleanup verification: Verify likes and bookmarks unchanged
  const likesCountAfter = await redis.scan('0', { match: 'likes:*', count: 200 });
  const bookmarksCountAfter = await redis.scan('0', { match: 'bookmarks:*', count: 200 });
  const afterLikes = likesCountAfter[1].length;
  const afterBookmarks = bookmarksCountAfter[1].length;

  console.log(`\nüõ°Ô∏è  PROTECTED DATA VERIFICATION:`);
  console.log(
    `  Likes before: ${currentLikes} ‚Üí after: ${afterLikes} ${currentLikes === afterLikes ? '‚úÖ UNCHANGED' : '‚ùå CHANGED'}`
  );
  console.log(
    `  Bookmarks before: ${currentBookmarks} ‚Üí after: ${afterBookmarks} ${currentBookmarks === afterBookmarks ? '‚úÖ UNCHANGED' : '‚ùå CHANGED'}`
  );

  if (currentLikes !== afterLikes || currentBookmarks !== afterBookmarks) {
    console.error('\n‚ö†Ô∏è  WARNING: Likes or bookmarks count changed!');
    console.error('   This should not happen. Please investigate.\n');
  }

  console.log('üí° NEXT STEPS:');
  console.log('-'.repeat(80));
  console.log('‚úÖ Run: npm run redis:analyze to verify cleanup');
  console.log('‚úÖ Test your application to ensure everything works');
  console.log('‚úÖ Monitor for any errors in production\n');
}

main().catch(console.error);
